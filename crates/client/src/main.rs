use anyhow::{anyhow, bail, Context, Result};
use clap::Parser;
use common::{
    crypto::{client_input_sign_bytes, now_ms},
    proto::{ClientCmd, ClientInput, ClientToGs, PlayTicket, ServerHello, WorldSnapshot},
    tcp_framing::{tcp_recv_msg, tcp_send_msg},
};
use ed25519_dalek::{Signature, Signer, SigningKey, VerifyingKey};
use rand::rngs::OsRng;
use std::{fs, time::Duration};
use tokio::{net::TcpStream, time::sleep};

/// Read the pinned VS public key from disk (keys/vs_ed25519.pub).
/// This file is generated by gen_keys.exe / tools::smoke and is also what VS
/// and GS are using for this run.
///
/// Returns [u8;32] which should match ServerHello.vs_pub.
fn load_pinned_vs_pub() -> Result<[u8; 32]> {
    let bytes =
        fs::read("keys/vs_ed25519.pub").context("read VS pubkey from keys/vs_ed25519.pub")?;

    if bytes.len() != 32 {
        return Err(anyhow!(
            "vs_ed25519.pub length was {}, expected 32",
            bytes.len()
        ));
    }

    let mut pk = [0u8; 32];
    pk.copy_from_slice(&bytes);
    Ok(pk)
}

/// Pretty-print a [u8;32] as hex for logging / errors.
fn to_hex32(bytes: &[u8; 32]) -> String {
    let mut out = String::with_capacity(64);
    for b in bytes {
        out.push_str(&format!("{:02x}", b));
    }
    out
}

/// CLI options for the client-sim.
#[derive(Parser, Debug)]
struct Opts {
    /// Where gs-sim is serving the local client port.
    #[arg(long, default_value = "127.0.0.1:50000")]
    gs_addr: String,

    /// If set, we just run a short smoke loop, then exit.
    #[arg(long)]
    smoke_test: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let opts = Opts::parse();

    //
    // 0. Load the VS public key we expect to trust for THIS run.
    //    This is the keypair gen_keys.exe wrote to disk, and it's what VS
    //    will present to GS in JoinAccept, and what GS sends us in ServerHello.
    //
    let pinned_vs_pub = load_pinned_vs_pub()?;

    //
    // 1. Connect to GS "client port" (gs-sim exposes this on localhost).
    //
    let mut sock = TcpStream::connect(&opts.gs_addr)
        .await
        .with_context(|| format!("connect to {}", &opts.gs_addr))?;

    //
    // 2. Read ServerHello { session_id, ticket, vs_pub } from GS.
    //
    let sh: ServerHello = tcp_recv_msg(&mut sock).await.context("recv ServerHello")?;
    let ticket: PlayTicket = sh.ticket.clone();

    //
    // 3. Enforce VS key pinning.
    //
    // We compare the VS pubkey that GS reports (sh.vs_pub)
    // against the pinned key we just loaded from disk.
    // If they differ, GS is either lying, or we're talking to
    // a GS that was blessed by some *other* VS than the one we think is legit.
    //
    if sh.vs_pub != pinned_vs_pub {
        let got_hex = to_hex32(&sh.vs_pub);
        let want_hex = to_hex32(&pinned_vs_pub);
        bail!(
            "untrusted VS pubkey from GS.\n  got:  {}\n  want: {}",
            got_hex,
            want_hex
        );
    }

    //
    // 4. Generate an ephemeral client keypair for THIS run/session.
    //    (Eventually this becomes the player's persistent identity key.)
    //
    let client_sk = SigningKey::generate(&mut OsRng);
    let client_pub = client_sk.verifying_key().to_bytes();

    //
    // 5. Enforce that the ticket is actually meant for us, if it's bound.
    //    ticket.client_binding == [0u8;32] means "unbound / any client OK".
    //
    if ticket.client_binding != [0u8; 32] && ticket.client_binding != client_pub {
        bail!("ticket client_binding mismatch: this ticket isn't for our client_pub");
    }

    //
    // 6. Sanity: session_id should match in both hello + ticket.
    //
    if ticket.session_id != sh.session_id {
        bail!("ServerHello session mismatch between GS and ticket");
    }

    //
    // 7. Verify VS signature on the ticket body.
    //
    // VS signed this tuple EXACTLY:
    // (session_id, client_binding, counter, not_before_ms, not_after_ms, prev_ticket_hash)
    //
    let body_tuple = (
        ticket.session_id,
        ticket.client_binding,
        ticket.counter,
        ticket.not_before_ms,
        ticket.not_after_ms,
        ticket.prev_ticket_hash,
    );
    let body_bytes =
        bincode::serialize(&body_tuple).context("serialize PlayTicket body for verify")?;

    let vs_vk = VerifyingKey::from_bytes(&sh.vs_pub).context("vs_pub in ServerHello invalid")?;

    // ticket.sig_vs is [u8; 64], and dalek wants a Signature object.
    let sig_vs = Signature::from_bytes(&ticket.sig_vs);

    if vs_vk.verify_strict(&body_bytes, &sig_vs).is_err() {
        bail!("VS signature on PlayTicket did not verify");
    }

    //
    // 8. Print initial freshness info (debug / smoke output).
    //
    let now = now_ms();
    let fresh_now = ticket.not_before_ms.saturating_sub(500) <= now
        && now <= ticket.not_after_ms.saturating_add(500);

    println!(
        "[CLIENT] got ticket #{} (fresh={}) for session {}..",
        ticket.counter,
        fresh_now,
        hex::encode(&ticket.session_id[..4])
    );

    //
    // 9. Main loop:
    // While the ticket is fresh, keep:
    //   - building a signed ClientInput
    //   - wrapping it as ClientToGs::Input(...)
    //   - sending to GS
    //   - reading back WorldSnapshot { tick, you, others }
    //
    let mut next_nonce: u64 = 1;

    loop {
        // Check that the ticket is still within [not_before_ms, not_after_ms].
        let now = now_ms();
        let fresh = ticket.not_before_ms.saturating_sub(500) <= now
            && now <= ticket.not_after_ms.saturating_add(500);

        if !fresh {
            println!(
                "[CLIENT] ticket expired; stopping input (session {}.., ctr={})",
                hex::encode(&sh.session_id[..4]),
                ticket.counter
            );
            break;
        }

        // Command for this tick.
        // In real gameplay this would be a movement vector, ability, etc.
        let this_cmd = ClientCmd::Move { dx: 1.0, dy: 0.0 };

        //
        // Canonical bytes we sign.
        // Must match gs-sim's check using client_input_sign_bytes().
        //
        let sign_bytes = client_input_sign_bytes(
            &sh.session_id,
            ticket.counter,
            &ticket.sig_vs,
            next_nonce,
            &this_cmd,
        );

        // Sign with our ephemeral key.
        let sig = client_sk.sign(&sign_bytes);

        //
        // Build the ClientInput struct we send to GS.
        //
        let ci = ClientInput {
            session_id: sh.session_id,
            ticket_counter: ticket.counter,
            ticket_sig_vs: ticket.sig_vs, // stapled VS signature

            client_nonce: next_nonce,
            cmd: this_cmd,

            client_pub,
            client_sig: sig.to_bytes(), // our ed25519 signature
        };

        //
        // Send to GS.
        //
        let msg = ClientToGs::Input(ci);
        tcp_send_msg(&mut sock, &msg)
            .await
            .context("send ClientInput")?;

        println!(
            "[CLIENT] sent input with nonce={}, ctr={}",
            next_nonce, ticket.counter
        );

        //
        // Read the authoritative WorldSnapshot the GS just sent back.
        // Format:
        //   WorldSnapshot {
        //       tick: u64,
        //       you: (x,y),
        //       others: Vec<([u8;32], x, y)>
        //   }
        //
        match tcp_recv_msg::<WorldSnapshot>(&mut sock).await {
            Ok(ws) => {
                let (you_x, you_y) = ws.you;
                println!(
                    "[CLIENT] tick={} you=({:.2},{:.2}) others={} players",
                    ws.tick,
                    you_x,
                    you_y,
                    ws.others.len()
                );
            }
            Err(e) => {
                eprintln!("[CLIENT] failed to recv WorldSnapshot: {e:?}");
                break;
            }
        }

        next_nonce += 1;

        // Simulated frame pacing.
        sleep(Duration::from_millis(200)).await;

        // In smoke mode, don't run forever.
        if opts.smoke_test && next_nonce > 5 {
            break;
        }
    }

    // Give gs-sim a moment to log before exit (esp. in smoke_test).
    sleep(Duration::from_millis(100)).await;

    Ok(())
}
